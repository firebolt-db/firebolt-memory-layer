---
description: FML Memory Layer - MANDATORY for all sessions
globs:
alwaysApply: true
---

# FML (Firebolt Memory Layer) - ALWAYS USE

You MUST use FML for persistent memory in EVERY conversation. This is not optional.

## MANDATORY: Session Initialization (FIRST THING TO DO)

At the START of every conversation, BEFORE responding to any user request:

```
1. Call init_session with user_id "YOUR_USERNAME"
2. Call recall_memories with the user's query to get relevant context
3. Use the retrieved context to inform your response
```

## During Every Conversation

### Add to Working Memory
- After understanding the user's intent, add task context with `add_to_working_memory`
- Use content_type: "task_state" for current tasks
- Use content_type: "message" for important user statements
- Use content_type: "scratchpad" for your observations

### üîÑ AUTOMATIC Memory Extraction (DO THIS PROACTIVELY)

**After EVERY response you give**, silently scan for memorable content and store it WITHOUT being asked.

#### Auto-Store These Patterns (call `store_memory` automatically):
| Pattern Detected | Category | Importance |
|-----------------|----------|------------|
| Bug fix or error resolution | procedural.workflow | 0.9 |
| User explains how something works | semantic.domain | 0.85 |
| Architecture/design decision made | episodic.decision | 0.9 |
| New tool/library/API usage learned | procedural.tool_usage | 0.85 |
| User preference expressed (likes/dislikes) | preference.style | 0.8 |
| Configuration or setup steps | procedural.workflow | 0.85 |
| Project-specific knowledge | semantic.project | 0.8 |
| Person/team mentioned with role | semantic.entity | 0.7 |
| Workaround or gotcha discovered | procedural.pattern | 0.9 |
| User corrects your mistake | semantic.domain | 0.85 |

#### How to Auto-Extract:
1. **Don't announce** you're storing - just do it silently
2. **Summarize** the learning (don't store raw conversation)
3. **Extract entities** (tools, files, people, concepts)
4. **Set appropriate importance** based on table above
5. **Include context** that makes the memory useful later

#### Example Auto-Extraction:
```
User: "The Kafka connector takes 2 minutes to sync changes to Firebolt"
‚Üí Silently call: store_memory(
    user_id="johnkennedy",
    content="Firebolt Kafka connector latency: ~2 minutes from Kafka write to Firebolt visibility. Plan for this delay in real-time dashboards.",
    memory_category="procedural",
    memory_subtype="tool_usage",
    importance=0.85,
    entities="tool:kafka-connector,tool:firebolt"
)
```

### Explicit Triggers for `store_memory`:
| User Says | Action |
|-----------|--------|
| "Remember this/that" | Store immediately with importance 0.95 |
| "Save this for later" | Store with importance 0.9 |
| "This is important" | Store with importance 0.95 |
| "Don't forget" | Store with importance 0.9 |
| Any solution after debugging | Store as procedural/workflow |

### üîÑ Periodic Checkpoint (Every 5-10 exchanges)
After extended conversations, call `checkpoint_working_memory` to auto-promote important items to long-term storage.

### End of Conversation Checkpoint
When conversation is winding down or user says goodbye:
- Call `checkpoint_working_memory(session_id, user_id)` to auto-promote important working memory items to long-term storage
- This analyzes relevance and importance automatically

### Get Context Before Complex Tasks
Before starting multi-step tasks, call `get_relevant_context` to assemble:
- Working memory (current session)
- Long-term memories (past learnings)
- Related project context

## üîÅ LEARNING LOOP: Blocks & Issues (MANDATORY)

When you encounter ANY block, error, or permission issue, follow this protocol:

### Step 1: Check FML First
**BEFORE** trying to solve the issue yourself:
```
recall_memories(user_id="johnkennedy", query="<error message or issue description>")
```
Look for past solutions, workarounds, or troubleshooting steps.

### Step 2: If FML Has Solution
- Apply the solution from memory
- Note: "Found solution in FML memory" (no need to announce unless relevant)

### Step 3: If FML Doesn't Have Solution
After resolving the issue:
```
store_memory(
    user_id="johnkennedy",
    content="[Issue]: <brief description>\n[Solution]: <what fixed it>\n[Pre-check]: <how to avoid in future>",
    memory_category="procedural",
    memory_subtype="troubleshooting",
    importance=0.9,
    entities="error:<error_type>,tool:<relevant_tool>"
)
```

### Step 4: Track Recurring Issues
For EVERY block/issue encountered, log it to working memory:
```
add_to_working_memory(
    session_id="...",
    content="ISSUE_LOG: <issue_type> | <brief_description> | <resolution>",
    content_type="scratchpad"
)
```

### Step 5: Three-Strike Rule
When you encounter the SAME type of issue for the **3rd time** (check FML for count):
1. **STOP** and notify the user:
   > "I've encountered this issue 3 times now: [issue description]. Would you like me to add a pre-hook or sanity check to prevent this in future sessions?"
2. If user agrees, create a procedural memory with:
   - Pre-check steps to run BEFORE the task
   - Validation criteria
   - Automatic remediation steps

### Common Pre-Hook Patterns

| Issue Type | Pre-Hook Check |
|------------|----------------|
| Permission denied (GitHub) | `gh api user` to verify auth, check org membership |
| Server running stale code | Check `/api/version` endpoint for `needs_restart` |
| Module not found | Verify venv activated, check PYTHONPATH |
| Database connection failed | Test connection with simple query first |
| Git push rejected | Run `git status`, check remote exists |

### Example Pre-Hook Memory
```
store_memory(
    content="PRE-HOOK: GitHub Org Repo Creation\n\nBefore attempting to create repo in an org:\n1. Check membership: gh api user/memberships/orgs/<org>\n2. Check create permission: look for 'admin' or 'maintain' role\n3. If member but no create rights, inform user they need to create manually or request permission\n\nThis avoids the 'does not have correct permissions to execute CreateRepository' error.",
    memory_category="procedural",
    memory_subtype="pattern",
    importance=0.95,
    entities="tool:github,tool:gh-cli,error:permission"
)
```

## Memory Categories

| Category | Use For |
|----------|---------|
| `episodic` | Events, decisions, what happened |
| `semantic` | Facts, entities, project knowledge |
| `procedural` | How-to, workflows, patterns |
| `preference` | User preferences, styles |

## CRITICAL: Security Rules (NEVER VIOLATE)

### Never Store in FML:
- Actual passwords, API keys, secrets, or tokens
- Values matching: sk-*, ghp_*, AKIA*, bearer tokens
- Anything from .env files
- Firebolt credentials, OpenAI keys, AWS secrets

### Always Enforce:
1. Before ANY git push, remind about credential scanning
2. Never echo back credential values
3. For new projects, include git-secrets and pre-commit setup
4. Check recall_memories for security rules on any repo work

### If Asked for Credentials:
Say: "Credentials are stored securely in .env files and should not be shared via chat. Check your local .env file."

## Quick Reference

```python
# Start session (REQUIRED - DO THIS FIRST)
init_session(user_id="YOUR_USERNAME")

# Get context for current task
recall_memories(user_id="YOUR_USERNAME", query="<user's question>")

# Track current work
add_to_working_memory(session_id="...", content="...", content_type="task_state")

# Save important learnings
store_memory(user_id="YOUR_USERNAME", content="...", memory_category="semantic")

# Get combined context for complex tasks
get_relevant_context(session_id="...", user_id="YOUR_USERNAME", query="...", token_budget=4000)
```

## Verification

If you're reading this rule, FML is configured. The FML MCP server runs at:
- MCP Server: Launched by Cursor via ~/.cursor/mcp.json
- HTTP API: http://localhost:8082 (for dashboard)
- Brain: Local Firebolt Core at http://localhost:3473
